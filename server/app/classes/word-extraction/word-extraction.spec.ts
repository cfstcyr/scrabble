/* eslint-disable no-console */
/* eslint-disable dot-notation */
/* eslint-disable max-lines */
import { Board, Orientation, Position } from '@app/classes/board';
import { POSITION_OUT_OF_BOARD } from '@app/classes/board/board-errors';
import { Square } from '@app/classes/square';
import { Tile } from '@app/classes/tile';
import { BOARD_SIZE } from '@app/constants/game';
import { expect, spy } from 'chai';
import { WordExtraction } from './word-extraction';
import { EXTRACTION_SQUARE_ALREADY_FILLED, EXTRACTION_TILES_INVALID } from './word-extraction-errors';

const TILE_J: Tile = { letter: 'J', value: 1 };
const TILE_A: Tile = { letter: 'A', value: 1 };
const TILE_M: Tile = { letter: 'M', value: 1 };
const TILE_B: Tile = { letter: 'B', value: 1 };
const TILE_O: Tile = { letter: 'O', value: 1 };
const TILE_N: Tile = { letter: 'N', value: 1 };
const WORD_JAMBON: Tile[] = [TILE_J, TILE_A, TILE_M, TILE_B, TILE_O, TILE_N];
const WORD_BON: Tile[] = [TILE_B, TILE_O, TILE_N];

describe('WordExtraction', () => {
    let board: Board;
    let grid: Square[][];
    beforeEach(async () => {
        grid = [];
        for (let i = 0; i < BOARD_SIZE.y; i++) {
            grid[i] = [];
            for (let j = 0; j < BOARD_SIZE.x; j++) {
                const square = {
                    tile: null,
                    position: { row: i, column: j },
                    scoreMultiplier: null,
                    wasMultiplierUsed: false,
                    isCenter: false,
                };
                grid[i][j] = square;
            }
        }
        board = new Board(grid);
    });

    it('should create', () => {
        // eslint-disable-next-line @typescript-eslint/no-unused-expressions, no-unused-expressions
        expect(WordExtraction).to.exist;
    });

    it('extract should throw an EXTRACTION_POSITION_OUT_OF_BOARD when the board grid is an empty array', () => {
        const startPosition: Position = { row: 1, column: 7 };
        const orientation = Orientation.Vertical;
        board.grid = [[]];
        const result = () => WordExtraction.extract(board, WORD_JAMBON, startPosition, orientation);
        expect(result).to.throw(POSITION_OUT_OF_BOARD);
    });

    it('extract should throw an EXTRACTION_TILES_INVALID when the TilesToPlace is empty', () => {
        const startPosition = { row: 1, column: 12 };
        const orientation = Orientation.Vertical;
        const result = () => WordExtraction.extract(board, [], startPosition, orientation);
        expect(result).to.throw(EXTRACTION_TILES_INVALID);
    });

    it('extract should throw an EXTRACTION_TILES_INVALID when the TilesToPlace is too big', () => {
        const startPosition = { row: 1, column: 12 };
        const orientation = Orientation.Vertical;
        const BIG_WORD = WORD_JAMBON.concat(WORD_JAMBON).concat(WORD_JAMBON);
        const result = () => WordExtraction.extract(board, BIG_WORD, startPosition, orientation);
        expect(result).to.throw(EXTRACTION_TILES_INVALID);
    });

    it('extract should throw an EXTRACTION_SQUARE_ALREADY_FILLED when the given position is already filled', () => {
        const startPosition = { row: 1, column: 12 };
        board.grid[startPosition.row][startPosition.column].tile = TILE_O;
        const orientation = Orientation.Vertical;
        const result = () => WordExtraction.extract(board, WORD_JAMBON, startPosition, orientation);
        expect(result).to.throw(EXTRACTION_SQUARE_ALREADY_FILLED);
    });

    it('extract should return the squares and tiles of the word generated by the TilesToPlace when the board is empty', () => {
        const startPosition: Position = { row: 1, column: 7 };
        const orientation = Orientation.Vertical;
        const expected: [Square, Tile][][] = [
            [
                [board.grid[startPosition.row][startPosition.column], TILE_B],
                [board.grid[startPosition.row + 1][startPosition.column], TILE_O],
                [board.grid[startPosition.row + 2][startPosition.column], TILE_N],
            ],
        ];
        expect(WordExtraction.extract(board, WORD_BON, startPosition, orientation)).to.deep.equal(expected);
    });

    it('extract should return the squares and tiles of the word generated by the TilesToPlace when the board already has a word (Horizontal)', () => {
        const startPosition: Position = { row: 1, column: 7 };
        const orientation = Orientation.Horizontal;
        board.grid[startPosition.row][startPosition.column + 1].tile = TILE_A;
        const expected: [Square, Tile][][] = [
            [
                [board.grid[startPosition.row][startPosition.column], TILE_B],
                [board.grid[startPosition.row][startPosition.column + 1], TILE_A],
                [board.grid[startPosition.row][startPosition.column + 2], TILE_O],
                [board.grid[startPosition.row][startPosition.column + 3], TILE_N],
            ],
        ];
        expect(WordExtraction.extract(board, WORD_BON, startPosition, orientation)).to.deep.equal(expected);
    });

    it('extract should return the squares and tiles of the word generated by the TilesToPlace when the board already has a word (Vertical)', () => {
        const startPosition: Position = { row: 1, column: 7 };
        const orientation = Orientation.Vertical;
        board.grid[startPosition.row + 2][startPosition.column].tile = TILE_J;
        const expected: [Square, Tile][][] = [
            [
                [board.grid[startPosition.row][startPosition.column], TILE_B],
                [board.grid[startPosition.row + 1][startPosition.column], TILE_O],
                [board.grid[startPosition.row + 2][startPosition.column], TILE_J],
                [board.grid[startPosition.row + 3][startPosition.column], TILE_N],
            ],
        ];
        expect(WordExtraction.extract(board, WORD_BON, startPosition, orientation)).to.deep.equal(expected);
    });

    it('extract should return a the list of the squares and tiles of words created (multiple words, horizontal)', () => {
        board.grid[0][0].tile = TILE_M; //   m, b
        board.grid[0][1].tile = TILE_B; //   @           → ADD JAMBON at @
        board.grid[2][0].tile = TILE_B; //   b
        const startPosition: Position = { row: 1, column: 0 };
        const orientation = Orientation.Horizontal;
        const expected: [Square, Tile][][] = [
            [
                [board.grid[startPosition.row - 1][startPosition.column], TILE_M],
                [board.grid[startPosition.row][startPosition.column], TILE_J],
                [board.grid[startPosition.row + 1][startPosition.column], TILE_B],
            ],
            [
                [board.grid[startPosition.row - 1][startPosition.column + 1], TILE_B],
                [board.grid[startPosition.row][startPosition.column + 1], TILE_A],
            ],
            [
                [board.grid[startPosition.row][startPosition.column], TILE_J],
                [board.grid[startPosition.row][startPosition.column + 1], TILE_A],
                [board.grid[startPosition.row][startPosition.column + 2], TILE_M],
                [board.grid[startPosition.row][startPosition.column + 3], TILE_B],
                // eslint-disable-next-line @typescript-eslint/no-magic-numbers
                [board.grid[startPosition.row][startPosition.column + 4], TILE_O],
                // eslint-disable-next-line @typescript-eslint/no-magic-numbers
                [board.grid[startPosition.row][startPosition.column + 5], TILE_N],
            ],
        ];
        expect(WordExtraction.extract(board, WORD_JAMBON, startPosition, orientation)).to.deep.equal(expected);
    });

    it('extract should return a the list of the squares and tiles of words created (multiple words, vertical)', () => {
        board.grid[0][1].tile = TILE_A; //    A
        board.grid[2][0].tile = TILE_B; //    @      ↓ ADD JAMBON at @
        board.grid[3][0].tile = TILE_O; // B    A
        board.grid[2][2].tile = TILE_A; // O
        const startPosition: Position = { row: 1, column: 1 };
        const orientation = Orientation.Vertical;
        const expected: [Square, Tile][][] = [
            [
                [board.grid[startPosition.row + 1][startPosition.column - 1], TILE_B],
                [board.grid[startPosition.row + 1][startPosition.column], TILE_A],
                [board.grid[startPosition.row + 1][startPosition.column + 1], TILE_A],
            ],
            [
                [board.grid[startPosition.row + 2][startPosition.column - 1], TILE_O],
                [board.grid[startPosition.row + 2][startPosition.column], TILE_M],
            ],
            [
                [board.grid[startPosition.row - 1][startPosition.column], TILE_A],
                [board.grid[startPosition.row][startPosition.column], TILE_J],
                [board.grid[startPosition.row + 1][startPosition.column], TILE_A],
                [board.grid[startPosition.row + 2][startPosition.column], TILE_M],
                [board.grid[startPosition.row + 3][startPosition.column], TILE_B],
                // eslint-disable-next-line @typescript-eslint/no-magic-numbers
                [board.grid[startPosition.row + 4][startPosition.column], TILE_O],
                // eslint-disable-next-line @typescript-eslint/no-magic-numbers
                [board.grid[startPosition.row + 5][startPosition.column], TILE_N],
            ],
        ];
        expect(WordExtraction.extract(board, WORD_JAMBON, startPosition, orientation)).to.deep.equal(expected);
    });

    it('extractLeftWord should return the squares and tiles of the word left of the given empty position (Word middle of board)', () => {
        board.grid[1][4].tile = TILE_B; //
        board.grid[1][5].tile = TILE_O; //    B O N @
        board.grid[1][6].tile = TILE_N; //
        const startPosition = { row: 1, column: 7 };
        const expected: [Square, Tile][] = [
            [board.grid[1][4], TILE_B],
            [board.grid[1][5], TILE_O],
            [board.grid[1][6], TILE_N],
        ];
        expect(WordExtraction['extractLeftWord'](board, startPosition)).to.deep.equal(expected);
    });

    it('extractLeftWord should return an empty array if there is nothing left of the given empty position', () => {
        const startPosition = { row: 1, column: 1 };
        expect(WordExtraction['extractLeftWord'](board, startPosition)).to.deep.equal([]);
    });

    it('extractLeftWord should return an empty array if the given position is on th left edge of the board', () => {
        const startPosition = { row: 1, column: 0 }; // |@
        expect(WordExtraction['extractLeftWord'](board, startPosition)).to.deep.equal([]);
    });

    it('extractLeftWord should return the squares and tiles of the word left of the given empty position (Word on edge of board)', () => {
        board.grid[1][0].tile = TILE_B; //    |
        board.grid[1][1].tile = TILE_O; //    |B O N @
        board.grid[1][2].tile = TILE_N; //    |
        const startPosition = { row: 1, column: 3 };
        const expected: [Square, Tile][] = [
            [board.grid[1][0], TILE_B],
            [board.grid[1][1], TILE_O],
            [board.grid[1][2], TILE_N],
        ];
        expect(WordExtraction['extractLeftWord'](board, startPosition)).to.deep.equal(expected);
    });

    it('extractLeftWord should throw an error if the given position already has a tile', () => {
        board.grid[1][2].tile = TILE_N;
        const startPosition = { row: 1, column: 2 };
        const result = () => WordExtraction['extractLeftWord'](board, startPosition);
        expect(result).to.throw(EXTRACTION_SQUARE_ALREADY_FILLED);
    });

    it('extractLeftWord should throw an error if the given position is out of the board grid', () => {
        const startPosition = { row: -1, column: 100 };
        const result = () => WordExtraction['extractLeftWord'](board, startPosition);
        expect(result).to.throw(POSITION_OUT_OF_BOARD);
    });

    it('extractRightWord should return the squares and tiles of the word right of the given empty position (Word middle of board)', () => {
        board.grid[1][2].tile = TILE_B; //
        board.grid[1][3].tile = TILE_O; //   @ B O N
        board.grid[1][4].tile = TILE_N; //
        const startPosition = { row: 1, column: 1 };
        const expected: [Square, Tile][] = [
            [board.grid[1][2], TILE_B],
            [board.grid[1][3], TILE_O],
            [board.grid[1][4], TILE_N],
        ];
        expect(WordExtraction['extractRightWord'](board, startPosition)).to.deep.equal(expected);
    });

    it('extractRightWord should return an empty array if there is nothing right of the given empty position', () => {
        const startPosition = { row: 1, column: 1 };
        expect(WordExtraction['extractRightWord'](board, startPosition)).to.deep.equal([]);
    });

    it('extractRightWord should return an empty array if the given position is on th right edge of the board', () => {
        const startPosition = { row: 1, column: board.grid[0].length - 1 }; //   @|
        // eslint-disable-next-line dot-notation
        expect(WordExtraction['extractRightWord'](board, startPosition)).to.deep.equal([]);
    });

    it('extractRightWord should return the squares and tiles of the word right of the given empty position (Word on edge of board)', () => {
        board.grid[1][board.grid[1].length - 3].tile = TILE_B; //             |
        board.grid[1][board.grid[1].length - 2].tile = TILE_O; //      @ B O N|
        board.grid[1][board.grid[1].length - 1].tile = TILE_N; //             |
        // eslint-disable-next-line @typescript-eslint/no-magic-numbers
        const startPosition = { row: 1, column: board.grid[1].length - 4 };
        const expected: [Square, Tile][] = [
            [board.grid[1][board.grid[1].length - 3], TILE_B],
            [board.grid[1][board.grid[1].length - 2], TILE_O],
            [board.grid[1][board.grid[1].length - 1], TILE_N],
        ];
        expect(WordExtraction['extractRightWord'](board, startPosition)).to.deep.equal(expected);
    });

    it('extractRightWord should throw an error if the given position already has a tile', () => {
        board.grid[1][2].tile = TILE_B;
        const result = () => WordExtraction['extractRightWord'](board, { row: 1, column: 2 });
        expect(result).to.throw(EXTRACTION_SQUARE_ALREADY_FILLED);
    });

    it('extractRightWord should throw an error if the given position is out of the board grid', () => {
        const startPosition = { row: -1, column: 100 };
        const result = () => WordExtraction['extractRightWord'](board, startPosition);
        expect(result).to.throw(POSITION_OUT_OF_BOARD);
    });

    it('extractUpWord should return the squares and tiles of the word up of the given empty position (Word middle of board)', () => {
        board.grid[4][1].tile = TILE_B; //                  B
        board.grid[5][1].tile = TILE_O; //                  O
        board.grid[6][1].tile = TILE_N; //                  N
        const startPosition = { row: 7, column: 1 }; //     @
        const expected: [Square, Tile][] = [
            [board.grid[4][1], TILE_B],
            [board.grid[5][1], TILE_O],
            [board.grid[6][1], TILE_N],
        ];
        expect(WordExtraction['extractUpWord'](board, startPosition)).to.deep.equal(expected);
    });

    it('extractUpWord should return an empty array if there is nothing up of the given empty position', () => {
        const startPosition = { row: 1, column: 1 };
        expect(WordExtraction['extractUpWord'](board, startPosition)).to.deep.equal([]);
    });

    it('extractUpWord should return an empty array if the given position is on the upper edge of the board', () => {
        const startPosition = { row: 0, column: 1 };
        expect(WordExtraction['extractUpWord'](board, startPosition)).to.deep.equal([]);
    });

    it('extractUpWord should return the squares and tiles of the word up of the given empty position (Word on edge of board)', () => {
        //                                                 ___
        board.grid[0][1].tile = TILE_B; //                  B
        board.grid[1][1].tile = TILE_O; //                  O
        board.grid[2][1].tile = TILE_N; //                  N
        const startPosition = { row: 3, column: 1 }; //     @
        const expected: [Square, Tile][] = [
            [board.grid[0][1], TILE_B],
            [board.grid[1][1], TILE_O],
            [board.grid[2][1], TILE_N],
        ];
        expect(WordExtraction['extractUpWord'](board, startPosition)).to.deep.equal(expected);
    });

    it('extractUpWord should throw an error if the given position already has a tile', () => {
        board.grid[2][1].tile = TILE_B;
        const startPosition = { row: 2, column: 1 };
        const result = () => WordExtraction['extractUpWord'](board, startPosition);
        expect(result).to.throw(EXTRACTION_SQUARE_ALREADY_FILLED);
    });

    it('extractUpWord should throw an error if the given position is out of the board grid', () => {
        const startPosition = { row: -1, column: 100 };
        const result = () => WordExtraction['extractUpWord'](board, startPosition);
        expect(result).to.throw(POSITION_OUT_OF_BOARD);
    });

    it('extractDownWord should return the squares and tiles of the word down of the given empty position (Word middle of board)', () => {
        const startPosition = { row: 3, column: 1 }; //     @
        board.grid[4][1].tile = TILE_B; //                  B
        board.grid[5][1].tile = TILE_O; //                  O
        board.grid[6][1].tile = TILE_N; //                  N
        const expected: [Square, Tile][] = [
            [board.grid[4][1], TILE_B],
            [board.grid[5][1], TILE_O],
            [board.grid[6][1], TILE_N],
        ];
        expect(WordExtraction['extractDownWord'](board, startPosition)).to.deep.equal(expected);
    });

    it('extractDownWord should return an empty array if there is nothing down of the given empty position', () => {
        const startPosition = { row: 1, column: 1 };
        expect(WordExtraction['extractDownWord'](board, startPosition)).to.deep.equal([]);
    });

    it('extractDownWord should return an empty array if the given position is on the bottom edge of the board', () => {
        const startPosition = { row: board.grid.length - 1, column: 1 };
        expect(WordExtraction['extractDownWord'](board, startPosition)).to.deep.equal([]);
    });

    it('extractDownWord should return the squares and tiles of the word down of the given empty position (Word on edge of board)', () => {
        // eslint-disable-next-line @typescript-eslint/no-magic-numbers
        const startPosition = { row: board.grid.length - 4, column: 1 }; //     @
        board.grid[board.grid.length - 3][1].tile = TILE_B; //                  B
        board.grid[board.grid.length - 2][1].tile = TILE_O; //                  O
        board.grid[board.grid.length - 1][1].tile = TILE_N; //                  N
        //                                                                     ___
        const expected: [Square, Tile][] = [
            [board.grid[board.grid.length - 3][1], TILE_B],
            [board.grid[board.grid.length - 2][1], TILE_O],
            [board.grid[board.grid.length - 1][1], TILE_N],
        ];
        expect(WordExtraction['extractDownWord'](board, startPosition)).to.deep.equal(expected);
    });

    it('extractDownWord should throw an error if the given position already has a tile', () => {
        board.grid[4][1].tile = TILE_O;
        const result = () => WordExtraction['extractDownWord'](board, { row: 4, column: 1 });
        expect(result).to.throw(EXTRACTION_SQUARE_ALREADY_FILLED);
    });

    it('extractDownWord should throw an error if the given position is out of the board grid', () => {
        const startPosition = { row: -1, column: 100 };
        const result = () => WordExtraction['extractDownWord'](board, startPosition);
        expect(result).to.throw(POSITION_OUT_OF_BOARD);
    });

    it('extractVerticalWord should return the squares and tiles of the following word {UpWord} + {tileToAdd} + {DownWord}', () => {
        board.grid[6][1].tile = TILE_N; //                  N
        const startPosition = { row: 7, column: 1 }; //     @   <-- A
        board.grid[8][1].tile = TILE_J; //                  J
        board.grid[9][1].tile = TILE_A; //                  A
        const expected: [Square, Tile][] = [
            [board.grid[6][1], TILE_N],
            [board.grid[7][1], TILE_A],
            [board.grid[8][1], TILE_J],
            [board.grid[9][1], TILE_A],
        ];
        expect(WordExtraction['extractVerticalWord'](board, startPosition, TILE_A)).to.deep.equal(expected);
    });

    it('extractHorizontalWord should return the squares and tiles of the following word {LeftWord} + {tileToAdd} + {Right} (middle of board)', () => {
        board.grid[1][5].tile = TILE_O;
        board.grid[1][6].tile = TILE_N;
        const startPosition = { row: 1, column: 7 }; // ON@J
        board.grid[1][8].tile = TILE_J;
        const expected: [Square, Tile][] = [
            [board.grid[1][5], TILE_O],
            [board.grid[1][6], TILE_N],
            [board.grid[1][7], TILE_A],
            [board.grid[1][8], TILE_J],
        ];
        expect(WordExtraction['extractHorizontalWord'](board, startPosition, TILE_A)).to.deep.equal(expected);
    });
    it('extractHorizontalWord should call extractLeftWord and extractRightWord', () => {
        const rightSpy = spy.on(WordExtraction, 'extractRightWord', () => 'r');
        const leftSpy = spy.on(WordExtraction, 'extractLeftWord', () => 'l');
        const startPosition = { row: 3, column: 3 };
        WordExtraction['extractHorizontalWord'](board, startPosition, TILE_A);
        // eslint-disable-next-line @typescript-eslint/no-unused-expressions, no-unused-expressions
        expect(leftSpy).to.have.been.called.once;
        // eslint-disable-next-line @typescript-eslint/no-unused-expressions, no-unused-expressions
        expect(rightSpy).to.have.been.called.once;
    });
});
