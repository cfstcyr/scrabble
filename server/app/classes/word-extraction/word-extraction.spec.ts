import { expect } from 'chai';
import { Board, Orientation, Position, Square } from '@app/classes/board';
import { Tile } from '@app/classes/tile';
import { WordExtraction } from './word-extraction';
import { EXTRACTION_SQUARE_ALREADY_FILLED, EXTRACTION_POSITION_OUT_OF_BOARD, EXTRACTION_TILES_INVALID } from './word-extraction-errors';
import { SinonStubbedInstance } from 'sinon';

const TILE_J: Tile = { letter: 'J', value: 1 };
const TILE_A: Tile = { letter: 'A', value: 1 };
const TILE_M: Tile = { letter: 'M', value: 1 };
const TILE_B: Tile = { letter: 'B', value: 1 };
const TILE_O: Tile = { letter: 'O', value: 1 };
const TILE_N: Tile = { letter: 'N', value: 1 };
// const TILE_S: Tile = { letter: 'N', value: 1 };
const WORD_JAMBON: Tile[] = [TILE_J, TILE_A, TILE_M, TILE_B, TILE_O, TILE_N];
// const WORD_NON: Tile[] = [TILE_N, TILE_O, TILE_N];
// const WORD_MA: Tile[] = [TILE_M, TILE_A];
const WORD_BON: Tile[] = [TILE_B, TILE_O, TILE_N];
// SinonStubbedInstance
// // const getTilesPlaced = (board: Board, tilesPlaced: Tile[], startPosition: Position, orientation: Orientation): Square[] => {
// //     const locationWord: Square[] = [];
// //     for (let i = 0; i < locationWord.length; i++) {
// //         if (orientation === Orientation.Vertical) locationWord.push(board.grid[startPosition.row + i][startPosition.column]);
// //         if (orientation === Orientation.Horizontal) locationWord.push(board.grid[startPosition.row][startPosition.column + i]);
// //     }
// //     return locationWord;
// // };

// class MockBoard {
//     // eslint-disable-next-line @typescript-eslint/no-magic-numbers
//     static boardGridSize: number = 6;
//     static mockSquare: Square = {
//         tile: undefined,
//         multiplier: 1,
//         multiplierType: undefined,
//         played: false,
//         row: 0,
//         column: 0,
//     };
//     grid: Square[][];

//     constructor() {
//         this.grid = [];
//         for (let i = 0; i < this.getGridSize(); i++) {
//             this.grid.push([]);
//             for (let j = 0; j < this.getGridSize(); j++) {
//                 this.grid[i].push(MockBoard.mockSquare);
//             }
//         }
//     }

//     getGridSize(): number {
//         return MockBoard.boardGridSize;
//     }
// }

describe('WordExtraction', () => {
    let wordExtraction: WordExtraction;
    let board: Board;
    beforeEach(async () => {
        wordExtraction = new WordExtraction();
        board = new Board();
    });
    // let board: Board;

    /* eslint-disable no-console */

    /* eslint-disable @typescript-eslint/no-magic-numbers */
    /* eslint-disable @typescript-eslint/no-unused-expressions */
    /* eslint-disable no-unused-expressions */
    it('should create', () => {
        // eslint-disable-next-line @typescript-eslint/no-unused-expressions, no-unused-expressions
        expect(wordExtraction).to.exist;
    });

    it('extract should throw an EXTRACTION_POSITION_OUT_OF_BOARD when the board grid is an empty array', () => {
        const startPosition: Position = { row: 1, column: 7 };
        const orientation = Orientation.Vertical;
        board.grid = [[]];
        const result = () => wordExtraction.extract(board, WORD_JAMBON, startPosition, orientation);
        expect(result).to.throw(EXTRACTION_POSITION_OUT_OF_BOARD);
    });

    it('extract should throw an EXTRACTION_TILES_INVALID when the TilesToPlace is empty', () => {
        const startPosition = { row: 1, column: 12 };
        const orientation = Orientation.Vertical;
        const result = () => wordExtraction.extract(board, [], startPosition, orientation);
        expect(result).to.throw(EXTRACTION_TILES_INVALID);
    });

    it('extract should throw an EXTRACTION_TILES_INVALID when the TilesToPlace is too big', () => {
        const startPosition = { row: 1, column: 12 };
        const orientation = Orientation.Vertical;
        const BIG_WORD = WORD_JAMBON.concat(WORD_JAMBON).concat(WORD_JAMBON);
        const result = () => wordExtraction.extract(board, BIG_WORD, startPosition, orientation);
        expect(result).to.throw(EXTRACTION_TILES_INVALID);
    });

    it('extract should throw an EXTRACTION_SQUARE_ALREADY_FILLED when the TileToPlace is too big', () => {
        const startPosition = { row: 1, column: 12 };
        board.grid[startPosition.row][startPosition.column].tile = TILE_O;
        const orientation = Orientation.Vertical;
        const result = () => wordExtraction.extract(board, WORD_JAMBON, startPosition, orientation);
        expect(result).to.throw(EXTRACTION_SQUARE_ALREADY_FILLED);
    });

    it('extract should return the word generated by the TilesToPlace when the board is empty', () => {
        const startPosition: Position = { row: 1, column: 7 };
        const orientation = Orientation.Vertical;
        console.log(wordExtraction.extract(board, WORD_JAMBON, startPosition, orientation));
        expect(wordExtraction.extract(board, WORD_JAMBON, startPosition, orientation)).to.equal([['JAMBON']]);
    });

    it('extract should return the word generated by the TilesToPlace when the board already has a word (Horizontal)', () => {
        const startPosition: Position = { row: 1, column: 7 };
        const orientation = Orientation.Horizontal;
        board.placeTile(TILE_O, { row: startPosition.row, column: startPosition.column + 1 });
        expect(wordExtraction.extract(board, WORD_JAMBON, startPosition, orientation)).to.equal([['JOAMBON']]);
    });

    it('extract should return the word generated by the TilesToPlace when the board already has a word (Vertical)', () => {
        const startPosition: Position = { row: 1, column: 7 };
        const orientation = Orientation.Vertical;
        board.placeTile(TILE_O, { row: startPosition.row + 3, column: startPosition.column });
        expect(wordExtraction.extract(board, WORD_JAMBON, startPosition, orientation)).to.equal([['JAMOBON']]);
    });

    it('extract should return a the list of words created when it creates many words', () => {
        const jambonPosition = { row: 0, column: 0 };
        const jambonOrientation = Orientation.Horizontal;
        board.placeWord(WORD_JAMBON, jambonPosition, jambonOrientation);
        const bonPosition = { row: 2, column: 2 };
        const bonOrientation = Orientation.Vertical;
        board.placeWord(WORD_BON, bonPosition, bonOrientation);
        const startPosition: Position = { row: 1, column: 2 };
        const orientation = Orientation.Horizontal;
        const expected = ['MJBON', 'BA', 'OM', 'NB', 'JAMBON'];
        expect(wordExtraction.extract(board, WORD_JAMBON, startPosition, orientation)).to.equal(expected);
    });

    it('extract should return a the list of words created when it creates many words', () => {
        const jambonPosition = { row: 0, column: 0 };
        const jambonOrientation = Orientation.Horizontal;
        board.placeWord(WORD_JAMBON, jambonPosition, jambonOrientation);
        const bonPosition = { row: 1, column: 2 };
        const bonOrientation = Orientation.Vertical;
        board.placeWord(WORD_BON, bonPosition, bonOrientation);
        const startPosition: Position = { row: 1, column: 3 };
        const orientation = Orientation.Vertical;
        const expected = ['BJ', 'OA', 'NM', 'BJAMBON'];
        expect(wordExtraction.extract(board, WORD_JAMBON, startPosition, orientation)).to.equal(expected);
    });

    it('extractLeftWord should return the word left of the given empty position (Word middle of board)', () => {
        const bonPosition = { row: 1, column: 4 };
        const orientation = Orientation.Horizontal;
        board.placeWord(WORD_BON, bonPosition, orientation);
        const startPosition = { row: bonPosition.row, column: bonPosition.column + WORD_BON.length };
        expect(wordExtraction.extractLeftWord(board, startPosition)).to.equal(['BON']);
    });

    it('extractLeftWord should return an empty string if there is nothing left of the given empty position', () => {
        const startPosition = { row: 1, column: 1 };
        expect(wordExtraction.extractLeftWord(board, startPosition)).to.equal('');
    });

    it('extractLeftWord should return an empty string if the given position is on th left edge of the board', () => {
        const startPosition = { row: 1, column: 0 };
        expect(wordExtraction.extractLeftWord(board, startPosition)).to.equal('');
    });

    it('extractLeftWord should return the word left of the given empty position (Word on edge of board)', () => {
        const bonPosition = { row: 1, column: 0 };
        const orientation = Orientation.Horizontal;
        board.placeWord(WORD_BON, bonPosition, orientation);
        const startPosition = { row: bonPosition.row, column: bonPosition.column + WORD_BON.length };
        expect(wordExtraction.extractLeftWord(board, startPosition)).to.equal(['BON']);
    });

    it('extractLeftWord should throw an error if the given position already has a tile', () => {
        const bonPosition = { row: 1, column: 0 };
        const orientation = Orientation.Horizontal;
        board.placeWord(WORD_BON, bonPosition, orientation);
        const result = wordExtraction.extractLeftWord(board, bonPosition);
        expect(result).to.throw(EXTRACTION_SQUARE_ALREADY_FILLED);
    });

    it('extractLeftWord should throw an error if the given position is out of the board grid', () => {
        const startPosition = { row: -1, column: 100 };
        const result = wordExtraction.extractLeftWord(board, startPosition);
        expect(result).to.throw(EXTRACTION_POSITION_OUT_OF_BOARD);
    });

    ////////////////////////

    it('extractRightWord should return the word right of the given empty position (Word middle of board)', () => {
        const bonPosition = { row: 1, column: 4 };
        const orientation = Orientation.Horizontal;
        board.placeWord(WORD_BON, bonPosition, orientation);
        const startPosition = { row: bonPosition.row, column: bonPosition.column - 1 };
        expect(wordExtraction.extractRightWord(board, startPosition)).to.equal(['BON']);
    });

    it('extractRightWord should return an empty string if there is nothing right of the given empty position', () => {
        const startPosition = { row: 1, column: 1 };
        expect(wordExtraction.extractRightWord(board, startPosition)).to.equal('');
    });

    it('extractRightWord should return an empty string if the given position is on th right edge of the board', () => {
        const startPosition = { row: 1, column: board.grid[0].length - 1 };
        expect(wordExtraction.extractRightWord(board, startPosition)).to.equal('');
    });

    it('extractRightWord should return the word right of the given empty position (Word on edge of board)', () => {
        const bonPosition = { row: 1, column: board.grid[0].length - (WORD_BON.length - 1) };
        const orientation = Orientation.Horizontal;
        board.placeWord(WORD_BON, bonPosition, orientation);
        const startPosition = { row: bonPosition.row, column: bonPosition.column - 1 };
        expect(wordExtraction.extractLeftWord(board, startPosition)).to.equal(['BON']);
    });

    it('extractRightWord should throw an error if the given position already has a tile', () => {
        const bonPosition = { row: 1, column: 0 };
        const orientation = Orientation.Horizontal;
        board.placeWord(WORD_BON, bonPosition, orientation);
        const result = wordExtraction.extractRightWord(board, bonPosition);
        expect(result).to.throw(EXTRACTION_SQUARE_ALREADY_FILLED);
    });

    it('extractRightWord should throw an error if the given position is out of the board grid', () => {
        const startPosition = { row: -1, column: 100 };
        const result = wordExtraction.extractRightWord(board, startPosition);
        expect(result).to.throw(EXTRACTION_POSITION_OUT_OF_BOARD);
    });

    ///////////////////////////////////////////////////////

    it('extractUpWord should return the word up of the given empty position (Word middle of board)', () => {
        const bonPosition = { row: 4, column: 1 };
        const orientation = Orientation.Vertical;
        board.placeWord(WORD_BON, bonPosition, orientation);
        const startPosition = { row: bonPosition.row + WORD_BON.length, column: bonPosition.column };
        expect(wordExtraction.extractUpWord(board, startPosition)).to.equal(['BON']);
    });

    it('extractUpWord should return an empty string if there is nothing up of the given empty position', () => {
        const startPosition = { row: 1, column: 1 };
        expect(wordExtraction.extractUpWord(board, startPosition)).to.equal('');
    });

    it('extractUpWord should return an empty string if the given position is on the upper edge of the board', () => {
        const startPosition = { row: 0, column: 1 };
        expect(wordExtraction.extractUpWord(board, startPosition)).to.equal('');
    });

    it('extractUpWord should return the word up of the given empty position (Word on edge of board)', () => {
        const bonPosition = { row: 0, column: 1 };
        const orientation = Orientation.Vertical;
        board.placeWord(WORD_BON, bonPosition, orientation);
        const startPosition = { row: bonPosition.row + WORD_BON.length, column: bonPosition.column };
        expect(wordExtraction.extractUpWord(board, startPosition)).to.equal(['BON']);
    });

    it('extractUpWord should throw an error if the given position already has a tile', () => {
        const bonPosition = { row: 1, column: 0 };
        const orientation = Orientation.Vertical;
        board.placeWord(WORD_BON, bonPosition, orientation);
        const result = wordExtraction.extractUpWord(board, bonPosition);
        expect(result).to.throw(EXTRACTION_SQUARE_ALREADY_FILLED);
    });

    it('extractUpWord should throw an error if the given position is out of the board grid', () => {
        const startPosition = { row: -1, column: 100 };
        const result = wordExtraction.extractUpWord(board, startPosition);
        expect(result).to.throw(EXTRACTION_POSITION_OUT_OF_BOARD);
    });

    ////////////////////////

    it('extractDownWord should return the word down of the given empty position (Word middle of board)', () => {
        const bonPosition = { row: 4, column: 1 };
        const orientation = Orientation.Vertical;
        board.placeWord(WORD_BON, bonPosition, orientation);
        const startPosition = { row: bonPosition.row - 1, column: bonPosition.column };
        expect(wordExtraction.extractUpWord(board, startPosition)).to.equal(['BON']);
    });

    it('extractDownWord should return an empty string if there is nothing down of the given empty position', () => {
        const startPosition = { row: 1, column: 1 };
        expect(wordExtraction.extractUpWord(board, startPosition)).to.equal('');
    });

    it('extractDownWord should return an empty string if the given position is on the bottom edge of the board', () => {
        const startPosition = { row: board.grid.length - 1, column: 1 };
        expect(wordExtraction.extractUpWord(board, startPosition)).to.equal('');
    });

    it('extractDownWord should return the word down of the given empty position (Word on edge of board)', () => {
        const bonPosition = { row: 0, column: 1 };
        const orientation = Orientation.Vertical;
        board.placeWord(WORD_BON, bonPosition, orientation);
        const startPosition = { row: bonPosition.row - 1, column: bonPosition.column };
        expect(wordExtraction.extractUpWord(board, startPosition)).to.equal(['BON']);
    });

    it('extractDownWord should throw an error if the given position already has a tile', () => {
        const bonPosition = { row: 1, column: 0 };
        const orientation = Orientation.Vertical;
        board.placeWord(WORD_BON, bonPosition, orientation);
        const result = wordExtraction.extractUpWord(board, bonPosition);
        expect(result).to.throw(EXTRACTION_SQUARE_ALREADY_FILLED);
    });

    it('extractDownWord should throw an error if the given position is out of the board grid', () => {
        const startPosition = { row: -1, column: 100 };
        const result = wordExtraction.extractUpWord(board, startPosition);
        expect(result).to.throw(EXTRACTION_POSITION_OUT_OF_BOARD);
    });

    ///////////////////

    it('extractHorizontalWord should return the following word {leftWord} + {tileToAdd} + {rightWord} (Word middle of board)', () => {
        const bonPosition = { row: 1, column: 4 };
        const orientation = Orientation.Horizontal;
        board.placeWord(WORD_BON, bonPosition, orientation);
        const startPosition = { row: bonPosition.row, column: bonPosition.column + WORD_BON.length };
        expect(wordExtraction.extractHorizontalWord(board, startPosition)).to.equal(['BON']);
    });

    it('extractHorizontalWord should return the following word {leftWord} + {tileToAdd} + {rightWord} (Word middle of board)', () => {
        const bonPosition = { row: 1, column: 4 };
        const orientation = Orientation.Horizontal;
        board.placeWord(WORD_BON, bonPosition, orientation);
        const startPosition = { row: bonPosition.row, column: bonPosition.column + WORD_BON.length };
        expect(wordExtraction.extractHorizontalWord(board, startPosition)).to.equal(['BON']);
    });
});

//  94

// 109-110

// 137
// 151 121

// 155
